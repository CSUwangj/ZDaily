+++
title = "2021-03-08 Daily-Challenge"
path = "2021-03-08-Daily-Challenge"
date = 2021-03-08 18:03:31+08:00
updated = 2021-03-08 18:33:28+08:00
in_search_index = true

[taxonomies]
tags = ["Algorithm"]
categories = [ "DailyChallenge",]
archives = [ "archive",]
+++

Today I have done [Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/) and leetcode's [March LeetCoding Challenge](https://leetcode.com/explore/challenge/card/march-leetcoding-challenge-2021/589/week-2-march-8th-march-14th/3665/) with `cpp`.

<!-- more -->

# Add to Array-Form of Integer

## Description

For a non-negative integer `X`, the *array-form of `X`* is an array of its digits in left to right order. For example, if `X = 1231`, then the array form is `[1,2,3,1]`.

Given the array-form `A` of a non-negative integer `X`, return the array-form of the integer `X+K`.

 



**Example 1:**

```
Input: A = [1,2,0,0], K = 34
Output: [1,2,3,4]
Explanation: 1200 + 34 = 1234
```

**Example 2:**

```
Input: A = [2,7,4], K = 181
Output: [4,5,5]
Explanation: 274 + 181 = 455
```

**Example 3:**

```
Input: A = [2,1,5], K = 806
Output: [1,0,2,1]
Explanation: 215 + 806 = 1021
```

**Example 4:**

```
Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1
Output: [1,0,0,0,0,0,0,0,0,0,0]
Explanation: 9999999999 + 1 = 10000000000
```

 

**Noteï¼š**

1. `1 <= A.length <= 10000`
2. `0 <= A[i] <= 9`
3. `0 <= K <= 10000`
4. If `A.length > 1`, then `A[0] != 0`

## Solution

``` cpp
class Solution {
public:
    vector<int> addToArrayForm(vector<int>& A, int K) {
        reverse(A.begin(), A.end());
        int carry = 0;
        int pos = 0;
        int len = A.size();
        while(carry || K) {
            int result = carry + K % 10;
            if(pos < len) result += A[pos];
            carry = result / 10;
            if(pos < len) A[pos] = result % 10;
            else A.push_back(result % 10);
            K /= 10;
            pos += 1;
        }
        reverse(A.begin(), A.end());
        return move(A);
    }
};
```

# March LeetCoding Challenge 8

## Description

**Remove Palindromic Subsequences**

Given a string `s` consisting only of letters `'a'` and `'b'`. In a single step you can remove one palindromic **subsequence** from `s`.

Return the minimum number of steps to make the given string empty.

A string is a subsequence of a given string, if it is generated by deleting some characters of a given string without changing its order.

A string is called palindrome if is one that reads the same backward as well as forward.

 

**Example 1:**

```
Input: s = "ababa"
Output: 1
Explanation: String is already palindrome
```

**Example 2:**

```
Input: s = "abb"
Output: 2
Explanation: "abb" -> "bb" -> "". 
Remove palindromic subsequence "a" then "bb".
```

**Example 3:**

```
Input: s = "baabb"
Output: 2
Explanation: "baabb" -> "b" -> "". 
Remove palindromic subsequence "baab" then "b".
```

**Example 4:**

```
Input: s = ""
Output: 0
```

 

**Constraints:**

- `0 <= s.length <= 1000`
- `s` only consists of letters 'a' and 'b'

## Solution

``` cpp
class Solution {
    bool isPalindrome(string &s) {
        int len = s.length();
        for(int i = 0; i * 2 < len; ++i) {
            if(s[i] != s[len - 1 - i]) return false;
        }
        return true;
    }
public:
    int removePalindromeSub(string s) {
        if(s.length() == 0) return 0;
        if(isPalindrome(s)) return 1;
        return 2;
    }
};
```
