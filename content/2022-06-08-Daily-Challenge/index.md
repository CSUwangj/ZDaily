+++
updated = 2022-06-08 18:14:00+08:00
title = "2022-06-08 Daily-Challenge"
path = "2022-06-08-Daily-Challenge"
date = 2022-06-08 18:12:00+08:00
in_search_index = true

[taxonomies]
tags = ["Algorithm"]
categories = [ "DailyChallenge",]
archives = [ "archive",]
+++

Today I have done leetcode's [June LeetCoding Challenge](https://leetcode.com/problems/remove-palindromic-subsequences/) with `cpp`.

<!-- more -->

# June LeetCoding Challenge 8

## Description

**Remove Palindromic Subsequences**

You are given a string `s` consisting **only** of letters `'a'` and `'b'`. In a single step you can remove one **palindromic subsequence** from `s`.

Return *the **minimum** number of steps to make the given string empty*.

A string is a **subsequence** of a given string if it is generated by deleting some characters of a given string without  changing its order. Note that a subsequence does **not** necessarily need to be contiguous.

A string is called **palindrome** if is one that reads the same backward as well as forward.

 

**Example 1:**

```
Input: s = "ababa"
Output: 1
Explanation: s is already a palindrome, so its entirety can be removed in a single step.
```

**Example 2:**

```
Input: s = "abb"
Output: 2
Explanation: "abb" -> "bb" -> "". 
Remove palindromic subsequence "a" then "bb".
```

**Example 3:**

```
Input: s = "baabb"
Output: 2
Explanation: "baabb" -> "b" -> "". 
Remove palindromic subsequence "baab" then "b".
```

 

**Constraints:**

- `1 <= s.length <= 1000`
- `s[i]` is either `'a'` or `'b'`.

## Solution

``` cpp
class Solution {
  bool isPalindrome(string &s) {
    int len = s.length();
    for(int i = 0; i * 2 < len; ++i) {
      if(s[i] != s[len - 1 - i]) return false;
    }
    return true;
  }
public:
  int removePalindromeSub(string s) {
    if(s.length() == 0) return 0;
    if(isPalindrome(s)) return 1;
    return 2;
  }
};

// Accepted
// 48/48 cases passed (4 ms)
// Your runtime beats 30.61 % of cpp submissions
// Your memory usage beats 97.7 % of cpp submissions (6.1 MB)
```
