<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <!-- viewport-fit=cover is to support iPhone X rounded corners and notch in landscape-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=10, viewport-fit=cover">

      <title>CSUwangj&#x27;s daily challenge</title>

      <!-- CSS -->
      <link rel="stylesheet" href="https://csuwangj.github.io/ZDaily/css/lib/font-awesome.min.css">
      <link rel="stylesheet" href="https://csuwangj.github.io/ZDaily/site.css">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Alegreya+Sans|Noto+Serif+SC">
      
      <!-- js -->
      <script type="text/javascript" charset="utf-8" src="https://csuwangj.github.io/ZDaily/js/sidebar.js"></script>
      

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" crossorigin="anonymous">
<script type="module">
import renderMathInElement from "https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.mjs";
const katex_config = {
  delimiters: [
    { left: "$$", right: "$$", display: true },
    { left: "$", right: "$", display: false },
  ],
  macros: {
    // Functions
    arccot: '\\operatorname{arccot}',
    arcsec: '\\operatorname{arcsec}',
    arccsc: '\\operatorname{arccsc}',
  }
}
renderMathInElement(document.body, katex_config);
</script>


      

      
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://csuwangj.github.io/ZDaily/rss.xml">
      
      

      
      
    </head>

    <body>
      
      
        <header name="header">
          <div>
            <div class="logo"><a href="https:&#x2F;&#x2F;csuwangj.github.io&#x2F;ZDaily&#x2F;">ZDaily</a></div>
            <nav class="menu">
              
                <a href="https:&#x2F;&#x2F;csuwangj.github.io&#x2F;ZDaily&#x2F;" class="nav-item-home unselectable">
                  <span><i class="fa-solid fa-house"></i> Home</span>
                </a>
              
                <a href="https:&#x2F;&#x2F;csuwangj.github.io&#x2F;ZDaily&#x2F;about" class="nav-item-about unselectable">
                  <span><i class="fa-solid fa-user-circle"></i> About</span>
                </a>
              
                <a href="https:&#x2F;&#x2F;csuwangj.github.io&#x2F;ZDaily&#x2F;categories" class="nav-item-categories unselectable">
                  <span><i class="fa-solid fa-book"></i> Categories</span>
                </a>
              
                <a href="https:&#x2F;&#x2F;csuwangj.github.io&#x2F;ZDaily&#x2F;tags" class="nav-item-tags unselectable">
                  <span><i class="fa-solid fa-tags"></i> Tags</span>
                </a>
              
                <a href="https:&#x2F;&#x2F;csuwangj.github.io&#x2F;ZDaily&#x2F;archives" class="nav-item-archives unselectable">
                  <span><i class="fa-solid fa-inbox"></i> Archives</span>
                </a>
              
              
            </nav>
          </div>
        </header>
      

      <main class="content container" name="main">
        <div class="content-wrapper">
          
  <div class="post">
    <h1 class="post-title">2021-01-23 Daily-Challenge</h1>
    <div class="post-meta">
      
        <span class="post-meta-divider">|</span>
        <span class="post-meta-item-icon"><i class="fa-solid fa-calendar"></i></span>
        <span class="post-date">Posted on: </span>
        <time datetime=2021-01-23T16:08:00+08:00 title="post created">2021-01-23</time>
      
      
        <span class="post-meta-divider">|</span>
        <span class="post-meta-item-icon"><i class="fa-solid fa-calendar-check"></i></span>
        <span class="modify-date">Posted modified: </span>
        <time datetime=2021-01-24T00:37:57+08:00 title="post modified">2021-01-24</time>
      
      
        <span class="post-meta-divider">|</span>
        <span class="post-meta-item-icon"><i class="fa-solid fa-folder"></i></span>
        <span class="in-category">In: </span>
          
            <a class="category" href="/category/DailyChallenge">DailyChallenge</a>
          
      
      <span class="post-meta-divider">|</span>
    </div>
    <div class="post-body">
      <p>Today is Saturday, I gonna review the tasks I've done this week, and finish today's leetcode's <a href="https://leetcode.com/explore/challenge/card/january-leetcoding-challenge-2021/582/week-4-january-22nd-january-28th/3614/">January LeetCoding Challenge</a> with <code>cpp</code>.</p>
<p>BTW, I participated in Biweekly Contest 44.</p>
<span id="continue-reading"></span><h1 id="leetcode-review">LeetCode Review</h1>
<h2 id="regular-expression-matching">Regular Expression Matching</h2>
<p>more elegant</p>
<pre data-lang="cpp" class="language-cpp "><code class="language-cpp" data-lang="cpp">class Solution {
    int lenS;
    int lenP;
    string source;
    string pattern;
    
    bool match(char s, char p) {
        return p == &#x27;.&#x27; || s == p;
    }
    
    bool helper(int s, int p) {
        if(s == lenS) {
            while(p &lt; lenP-1 &amp;&amp; pattern[p+1] == &#x27;*&#x27;) p += 2;
            return p == lenP;
        }
        if(p == lenP) return s == lenS;
        
        if(p == lenP - 1 || pattern[p+1] != &#x27;*&#x27;) {
            if(match(source[s], pattern[p])) {
                return helper(s+1, p+1);
            }
            return false;
            
        } else {
            int pos = s;
            do {
                if(helper(pos, p+2)) return true;
            } while(pos &lt; lenS &amp;&amp; match(source[pos++], pattern[p]));
        }
        return false;
    }
public:
    bool isMatch(string s, string p) {
        source = s;
        pattern = p;
        lenS = s.length();
        lenP = p.length();
        return helper(0, 0);
    }
};
</code></pre>
<h2 id="count-the-repetitions">Count The Repetitions</h2>
<pre data-lang="cpp" class="language-cpp "><code class="language-cpp" data-lang="cpp">class Solution {
public:
    int getMaxRepetitions(string s1, int n1, string s2, int n2) {
        int len1 = s1.length();
        int len2 = s2.length();
        if(len1 * n1 &lt; len2 * n2) return 0;
        
        vector&lt;int&gt; indexChar(len2+1);
        vector&lt;int&gt; count(len2+1);
        
        int index = 0;
        int cnt = 0;
        for(int i = 0; i &lt; min(len2+1, n1); ++i) {
            for(int j = 0; j &lt; len1; ++j) {
                index += (s1[j] == s2[index]);
                if(index == len2) {
                    index = 0;
                    cnt += 1;
                }
            }
            indexChar[i] = index;
            count[i] = cnt;
            for(int j = 0; j &lt; i; ++j) {
                if(indexChar[j] == index) {
                    &#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; count[j] &lt;&lt; &#x27; &#x27; &lt;&lt; cnt &lt;&lt; endl;
                    int beforeLoop = count[j];
                    int loop = (cnt - count[j]) * ((n1 - 1 - j) &#x2F; (i - j));
                    int afterLoop = count[(n1 - 1 - j) % (i - j) + j] - count[j];
                    &#x2F;&#x2F; cout &lt;&lt; beforeLoop &lt;&lt; &#x27; &#x27; &lt;&lt; loop &lt;&lt; &#x27; &#x27; &lt;&lt; afterLoop;
                    return (beforeLoop + loop + afterLoop) &#x2F; n2;
                }
            }
        }
        return count[n1-1] &#x2F; n2;
    }
};
</code></pre>
<h2 id="maximum-number-of-non-overlapping-substrings">Maximum Number of Non-Overlapping Substrings</h2>
<pre data-lang="cpp" class="language-cpp "><code class="language-cpp" data-lang="cpp">class Solution {
    int l[128] = {0};
    int r[128] = {0};
    
    int getRight(string &amp;s, int left) {
        int right = r[s[left]];
        for(int i = left; i &lt; right; ++i) {
            int c = s[i];
            if(l[c] &lt; left) return -1;
            right = max(right, r[c]);
        }
        return right;
    }
    
    void init(string &amp;s) {
        memset(l, 0x3f, sizeof(l));
        memset(r, 0x3f, sizeof(r));
        int len = s.length();
        for(int i = 0; i &lt; len; ++i) {
            int c = s[i];
            l[c] = min(i, l[c]);
            r[c] = i;
        }
    }
public:
    vector&lt;string&gt; maxNumOfSubstrings(string s) {
        int len = s.length();
        init(s);
        
        int right = -1;
        vector&lt;string&gt; answer;
        for(int i = 0; i &lt; len; ++i) {
            if(i == l[s[i]]) {
                int currentRight = getRight(s, i);
                &#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; right &lt;&lt; currentRight &lt;&lt; endl;;
                if(currentRight == -1) continue;
                if(currentRight &lt; right) answer.back() = s.substr(i, currentRight-i+1);
                else answer.push_back(s.substr(i, currentRight-i+1));
                right = currentRight;
            }
        }
        return answer;
    }
};
</code></pre>
<h2 id="valid-parentheses">Valid Parentheses</h2>
<p>too easy to review</p>
<h2 id="longest-palindromic-substring">Longest Palindromic Substring</h2>
<p>still dp, optimization seems not working</p>
<pre data-lang="cpp" class="language-cpp "><code class="language-cpp" data-lang="cpp">class Solution {
    vector&lt;vector&lt;bool&gt;&gt; memo;
public:
    string longestPalindrome(string s) {
        int len = s.length();
        memo.resize(len+1, vector&lt;bool&gt;(len+1));
        for(int i = 0; i &lt; len; ++i) {
            memo[i][i] = true;
            memo[i][i+1] = true;
        }
        int answer = 1;
        int begin = 0;
        int lastfound = 1;
        for(int i = 2; i &lt;= len; ++i) {
            bool found = false;
            for(int j = 0; j+i &lt;= len; ++j) {
                if(memo[j+1][j+i-1] &amp;&amp; s[j] == s[j+i-1]) {
                    memo[j][j+i] = true;
                    answer = i;
                    begin = j;
                    found = true;
                    lastfound = i;
                }
            }
            if(!found &amp;&amp; i == lastfound+2) break;
        }
        return s.substr(begin, answer);
    }
};
</code></pre>
<p>find the string by expanding palindrome</p>
<pre data-lang="cpp" class="language-cpp "><code class="language-cpp" data-lang="cpp">class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.length();
        int answer = 1;
        int begin = 0;
        for(int i = 0; i &lt; len; ++i) {
            int left = i, right = i;
            while(left &gt; 0 &amp;&amp; right &lt; len &amp;&amp; s[left-1] == s[right]) {
                left -= 1;
                right += 1;
            }
            if(right - left &gt; answer) {
                answer = right - left;
                begin = left;
            }
            left = i, right = i;
            while(left &gt;= 0 &amp;&amp; right &lt; len &amp;&amp; s[left] == s[right]) {
                left -= 1;
                right += 1;
            }
            if(right - left - 1 &gt; answer) {
                answer = right - left - 1;
                begin = left + 1;
            }
            
        }
        return s.substr(begin, answer);
    }
};
</code></pre>
<h2 id="max-number-of-k-sum-pairs">Max Number of K-Sum Pairs</h2>
<p>too easy to review</p>
<h2 id="all-possible-full-binary-trees">All Possible Full Binary Trees</h2>
<p>less code make slower result</p>
<pre data-lang="cpp" class="language-cpp "><code class="language-cpp" data-lang="cpp">class Solution {
    vector&lt;vector&lt;TreeNode*&gt;&gt; FBTs;
    void generateFBTs(int N) {
        FBTs.resize(N+1);
        FBTs[1].push_back(new TreeNode(0));
        for(int i = 3; i &lt;= N; i += 2) {
            for(int j = 1; j &lt; i; j += 2) {
                for(auto left : FBTs[j]) {
                    for(auto right: FBTs[i-j-1]) {
                        FBTs[i].push_back(new TreeNode(0, deepcopy(left), deepcopy(right)));
                    }
                }
            }
        }
    }
    
    TreeNode* deepcopy(TreeNode *root) {
        if(!root) return nullptr;
        return new TreeNode(0, deepcopy(root-&gt;left), deepcopy(root-&gt;right));
    }
    
public:
    vector&lt;TreeNode*&gt; allPossibleFBT(int N) {
        if(N % 2 == 0) return vector&lt;TreeNode*&gt;();
        generateFBTs(N);
        return FBTs[N];
    }
};
</code></pre>
<h2 id="flip-equivalent-binary-trees">Flip Equivalent Binary Trees</h2>
<p>too easy to review</p>
<h2 id="number-of-segments-in-a-string">Number of Segments in a String</h2>
<p>too easy to review</p>
<h2 id="to-lower-case">To Lower Case</h2>
<p>too easy to review</p>
<h2 id="determine-if-two-strings-are-close">Determine if Two Strings Are Close</h2>
<p>too easy to review</p>
<h2 id="predict-the-winner">Predict the Winner</h2>
<p>better DP</p>
<pre data-lang="cpp" class="language-cpp "><code class="language-cpp" data-lang="cpp">class Solution {
public:
    bool PredictTheWinner(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len));
        for(int i = 0; i &lt; len; ++i) {
            dp[i][i] = nums[i];
        }
        for(int i = 1; i &lt; len; ++i) {
            for(int j = 0; j+i &lt; len; ++j) {
                dp[j][j+i] = max(nums[j]-dp[j+1][j+i], nums[j+i]-dp[j][j+i-1]);
            }
        }
        return dp[0][len-1] &gt;= 0;
    }
};
</code></pre>
<h2 id="find-the-most-competitive-subsequence">Find the Most Competitive Subsequence</h2>
<pre data-lang="cpp" class="language-cpp "><code class="language-cpp" data-lang="cpp">class Solution {
public:
    vector&lt;int&gt; mostCompetitive(vector&lt;int&gt;&amp; nums, int k) {
        vector&lt;int&gt; monoStack;
        int len = nums.size();
        vector&lt;int&gt; nextLess(len);
        for(int i = 0; i &lt; len; ++i) {
            while(monoStack.size() + (len - i) &gt; k &amp;&amp; monoStack.size() &amp;&amp; monoStack.back() &gt; nums[i]) monoStack.pop_back();
            monoStack.push_back(nums[i]);
        }
        while(monoStack.size() &gt; k) monoStack.pop_back();
        return move(monoStack);
    }
};
</code></pre>
<h1 id="january-leetcoding-challenge-23">January LeetCoding Challenge 23</h1>
<h2 id="description">Description</h2>
<p><strong>Sort the Matrix Diagonally</strong></p>
<p>A <strong>matrix diagonal</strong> is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end. For example, the <strong>matrix diagonal</strong> starting from <code>mat[2][0]</code>, where <code>mat</code> is a <code>6 x 3</code> matrix, includes cells <code>mat[2][0]</code>, <code>mat[3][1]</code>, and <code>mat[4][2]</code>.</p>
<p>Given an <code>m x n</code> matrix <code>mat</code> of integers, sort each <strong>matrix diagonal</strong> in ascending order and return <em>the resulting matrix</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/01/21/1482_example_1_2.png" alt="img" /></p>
<pre><code>Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>
</ul>
<h2 id="solution">Solution</h2>
<p>bubble sort</p>
<pre data-lang="cpp" class="language-cpp "><code class="language-cpp" data-lang="cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; diagonalSort(vector&lt;vector&lt;int&gt;&gt;&amp; mat) {
        int rows = mat.size();
        int cols = mat.front().size();
        for(int i = 0; i &lt; rows+cols-1; ++i) {
            int rowBegin = max(0, i+1-cols);
            int colBegin = rowBegin == 0 ? cols - 1 - i : 0;
            &#x2F;&#x2F; cout &lt;&lt; &#x27;#&#x27; &lt;&lt; rowBegin &lt;&lt; &#x27; &#x27; &lt;&lt; colBegin &lt;&lt; endl;
            for(int index = 0; rowBegin + index &lt; rows-1 &amp;&amp; colBegin + index &lt; cols-1; ++index) {
                for(int j = 1; rowBegin + j &lt; rows-index &amp;&amp; colBegin + j &lt; cols-index; ++j) {
                    &#x2F;&#x2F; cout &lt;&lt; rowBegin + j &lt;&lt; &#x27; &#x27; &lt;&lt; colBegin + j &lt;&lt; endl;
                    if(mat[rowBegin+j][colBegin+j] &lt; mat[rowBegin+j-1][colBegin+j-1]) {
                        swap(mat[rowBegin+j][colBegin+j], mat[rowBegin+j-1][colBegin+j-1]);
                    }
                }
            }
        }
        return move(mat);
    }
};
</code></pre>
<h1 id="biweekly-contest-44">Biweekly Contest 44</h1>
<h2 id="5645-find-the-highest-altitude">5645. Find the Highest Altitude</h2>
<p>There is a biker going on a road trip. The road trip consists of <code>n + 1</code> points at different altitudes. The biker starts his trip on point <code>0</code> with altitude equal <code>0</code>.</p>
<p>You are given an integer array <code>gain</code> of length <code>n</code> where <code>gain[i]</code> is the <strong>net gain in altitude</strong> between points <code>i</code> and <code>i + 1</code> for all (<code>0 &lt;= i &lt; n)</code>. Return <em>the <strong>highest altitude</strong> of a point.</em></p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: gain = [-5,1,5,0,-7]
Output: 1
Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: gain = [-4,-3,-2,-1,4,3,2]
Output: 0
Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>n == gain.length</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>-100 &lt;= gain[i] &lt;= 100</code></li>
</ul>
<h3 id="solution-1">Solution</h3>
<p>nothing to say</p>
<pre data-lang="cpp" class="language-cpp "><code class="language-cpp" data-lang="cpp">class Solution {
public:
    int largestAltitude(vector&lt;int&gt;&amp; gain) {
        int a = 0;
        int answer = 0;
        for(auto i : gain) {
            a += i;
            answer = max(a, answer);
        }
        return answer;
    }
};
</code></pre>
<h2 id="5646-minimum-number-of-people-to-teach">5646. Minimum Number of People to Teach</h2>
<p>On a social network consisting of <code>m</code> users and some friendships between users, two users can communicate with each other if they know a common language.</p>
<p>You are given an integer <code>n</code>, an array <code>languages</code>, and an array <code>friendships</code> where:</p>
<ul>
<li>There are <code>n</code> languages numbered <code>1</code> through <code>n</code>,</li>
<li><code>languages[i]</code> is the set of languages the <code>ith</code> user knows, and</li>
<li><code>friendships[i] = [ui, vi]</code> denotes a friendship between the users <code>ui</code> and <code>vi</code>.</li>
</ul>
<p>You can choose <strong>one</strong> language and teach it to some users so that all friends can communicate with each other. Return <em>the</em> <em><strong>minimum</strong></em> <em>number of users you need to teach.</em></p>
<p>Note that friendships are not transitive, meaning if <code>x</code> is a friend of <code>y</code> and <code>y</code> is a friend of <code>z</code>, this doesn't guarantee that <code>x</code> is a friend of <code>z</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]
Output: 1
Explanation: You can either teach user 1 the second language or user 2 the first language.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]
Output: 2
Explanation: Teach the third language to users 1 and 2, yielding two users to teach.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 500</code></li>
<li><code>languages.length == m</code></li>
<li><code>1 &lt;= m &lt;= 500</code></li>
<li><code>1 &lt;= languages[i].length &lt;= n</code></li>
<li><code>1 &lt;= languages[i][j] &lt;= n</code></li>
<li><code>1 &lt;= ui &lt; vi &lt;= languages.length</code></li>
<li><code>1 &lt;= friendships.length &lt;= 500</code></li>
<li>All tuples <code>(ui, vi)</code> are unique</li>
<li><code>languages[i]</code> contains only unique values</li>
</ul>
<h3 id="solution-2">Solution</h3>
<p>I misunderstand the problem, so just done it at 1:21:44</p>
<pre data-lang="cpp" class="language-cpp "><code class="language-cpp" data-lang="cpp">class Solution {
public:
    int minimumTeachings(int n, vector&lt;vector&lt;int&gt;&gt;&amp; languages, vector&lt;vector&lt;int&gt;&gt;&amp; friendships) {
        int m = languages.size();
        vector&lt;unordered_set&lt;int&gt;&gt; lang(m+1);
        for(int i = 0; i &lt; m; ++i) {
            lang[i+1] = unordered_set&lt;int&gt;(languages[i].begin(), languages[i].end());
        }
        vector&lt;bool&gt; sat;
        for(auto &amp;f : friendships) {
            bool s = false;
            for(auto l : lang[f[0]]) {
                if(lang[f[1]].count(l)) {
                    sat.push_back(true);
                    s = true;
                    break;
                }
            }
            if(!s) sat.push_back(false);
            
        }
        int answer = m;
        for(int i = 1; i &lt;= n; ++i) {
            int cnt = 0;
            for(int j = 0; j &lt; friendships.size(); ++j) {
                if(sat[j]) continue;
                &#x2F;&#x2F; cout &lt;&lt; friendships[j][0] &lt;&lt; &#x27; &#x27; &lt;&lt; friendships[j][1] &lt;&lt; endl;
                cnt += !lang[friendships[j][0]].count(i);
                cnt += !lang[friendships[j][1]].count(i);
                lang[friendships[j][0]].insert(i);
                lang[friendships[j][1]].insert(i);
            }
            answer = min(answer, cnt);
        }
        return answer;
    }
};
</code></pre>
<h2 id="5647-decode-xored-permutation">5647. Decode XORed Permutation</h2>
<p>There is an integer array <code>perm</code> that is a permutation of the first <code>n</code> positive integers, where <code>n</code> is always <strong>odd</strong>.</p>
<p>It was encoded into another integer array <code>encoded</code> of length <code>n - 1</code>, such that <code>encoded[i] = perm[i] XOR perm[i + 1]</code>. For example, if <code>perm = [1,3,2]</code>, then <code>encoded = [2,1]</code>.</p>
<p>Given the <code>encoded</code> array, return <em>the original array</em> <code>perm</code>. It is guaranteed that the answer exists and is unique.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: encoded = [3,1]
Output: [1,2,3]
Explanation: If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] = [3,1]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: encoded = [6,5,4,6]
Output: [2,4,1,5,3]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>3 &lt;= n &lt; 105</code></li>
<li><code>n</code> is odd.</li>
<li><code>encoded.length == n - 1</code></li>
</ul>
<h3 id="solution-3">Solution</h3>
<p>bitwise magic, haha, I like it.</p>
<pre data-lang="cpp" class="language-cpp "><code class="language-cpp" data-lang="cpp">class Solution {
public:
    vector&lt;int&gt; decode(vector&lt;int&gt;&amp; encoded) {
        int len = encoded.size() + 1;
        vector&lt;int&gt; answer(len);
        int exp = 0;
        while((1 &lt;&lt; exp) &lt; len) {
            for(int i = 1; i &lt; len; ++i) {
                if(encoded[i-1] &amp; (1&lt;&lt;exp)) answer[i] |= (((1&lt;&lt;exp) &amp; answer[i-1]) ^ (1&lt;&lt;exp));
                else answer[i] |= ((1&lt;&lt;exp) &amp; answer[i-1]);
            }
            int oneCnt = 0;
            for(int i = 0; i &lt; len; ++i) {
                if((answer[i] &amp; (1&lt;&lt;exp))) oneCnt += 1;
            }
            int needOne = (len+1) &#x2F; (1&lt;&lt;(exp+1)) * (1 &lt;&lt; exp) + max((len+1) % (1&lt;&lt;(exp+1)) - (1 &lt;&lt; exp), 0);
            if(needOne != oneCnt) {
                for(int i = 0; i &lt; len; ++i) answer[i] ^= (1&lt;&lt;exp);
            }
            exp += 1;
        }
        return answer;
    }
};
</code></pre>

    </div>
  </div>

        </div>

        
          <button class="sidebar-toggle" onclick="openSidebar()">O</button>
          <aside class="sidebar" name="sidebar">
            <div class="site-author" itemprop="author" itemtype="https://schema.org/Person">
              
              <img class="site-author-image" itemprop="image"
                src="https://csuwangj.github.io/ZDaily/img/avatar.png"
                alt="CSUwangj" />
              
              <p class="site-author-name unselectable">CSUwangj</p>
              <p class="site-author-quote">Just keep in mind that hacking is very rarely in a sequence.</p>
            </div>
            <div class="feed-link">
              
                <a rel="alternate" type="application/rss+xml" title="RSS" href="https://csuwangj.github.io/ZDaily/rss.xml">
                  RSS
                </a>
              
            </div>
            <div class="links-of-author">
              
                <a href="https:&#x2F;&#x2F;github.com&#x2F;CSUwangj" title="Github" class="author-link">
                  <i class="fa-brands fa-github"></i>
                </a>
              
                <a href="mailto:CSUwangj@protonmail.com" title="EMail" class="author-link">
                  <i class="fa-solid fa-envelope"></i>
                </a>
              
            </div>
            <div class="links-of-blogroll">
              
                <a href="https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;">blog</a>
              
            </div>
          </aside>
        

      </main>

      
        <footer name="footer">
          <div class="copyright">
            <span item="copyrightYear">© 2018-2022</span>
            <span class="author">CSUwangj</span>
          </div>
          <div class="powered-by">
            Powered by <a href="https://www.getzola.org/">Zola</a> Theme <a href="https://github.com/CSUwangj/DogFood">DogFood</a>
          </div>
        </footer>
      
    </body>

</html>